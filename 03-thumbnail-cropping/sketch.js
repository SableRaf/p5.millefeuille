let layers;const rectangleKeyframes=[{width:110,height:90,rotation:-.35},{width:340,height:240,rotation:.45},{width:220,height:150,rotation:.05},{width:150,height:320,rotation:-.15}],RECT_TRANSITION_FRAMES=24,RECT_HOLD_FRAMES=120;let rectangleState;const orbConfigs=[{radiusX:260,radiusY:120,size:110,speed:.013,wobble:.008,color:[120,220,255]},{radiusX:180,radiusY:160,size:80,speed:-.018,wobble:.011,color:[255,160,200]}];function setup(){createCanvas(720,480,WEBGL),rectMode(CENTER),angleMode(RADIANS),layers=createLayerSystem(),layers.createLayer("Backdrop"),layers.createLayer("Wandering Orbs").setOpacity(.92),layers.createLayer("Spinny Triangle"),layers.createLayer("Breathing Rectangle").setOpacity(.85),rectangleState=createRectangleState(),layers.createUI({position:"top-right",width:320,thumbnailAutoUpdate:!0,thumbnailUpdateEvery:10})}function draw(){renderLayer("Backdrop",drawBackdropLayer),renderLayer("Wandering Orbs",drawOrbsLayer),renderLayer("Spinny Triangle",drawTriangleLayer),renderLayer("Breathing Rectangle",drawRectangleLayer),layers.render(()=>{background(6,8,16)})}function renderLayer(e,t){layers.begin(e),clear(),t(),layers.end()}function drawBackdropLayer(){noStroke();for(let e=0;e<18;e++){const t=1.2*width-40*e,a=map(e,0,18,15,80);fill(20+3*e,40+4*e,80+3*e,a),circle(0,0,t)}stroke(255,255,255,20),noFill();for(let e=0;e<6;e++)rotateZ(.1),rect(0,0,420+40*e,220+20*e)}function drawOrbsLayer(){noStroke(),orbConfigs.forEach((e,t)=>{const a=frameCount*e.speed+1.5*t,r=cos(a)*e.radiusX,n=sin(1.3*a)*e.radiusY,c=e.size+18*sin(a*(1.5+.2*t)),i=200+30*sin(.5*a);fill(e.color[0],e.color[1],e.color[2],i),circle(r,n,c),fill(255,255,255,60),circle(r+12*sin(2*a),n+12*cos(2*a),.35*c)})}function drawTriangleLayer(){push();const e=.02*frameCount;rotateZ(e),scale(1+.15*sin(.01*frameCount)),stroke(255,130,180,180),strokeWeight(3),fill(255,100,150,80),beginShape(),vertex(-110,132),vertex(110,132),vertex(0,-154),endShape(CLOSE),pop()}function drawRectangleLayer(){updateRectangleAnimation(),push(),rotateZ(rectangleState.current.rotation||0);const{width:e,height:t}=rectangleState.current;noStroke(),fill(255,210,140,200),rect(0,0,e,t,24),stroke(255,255,255,70),noFill(),rect(0,0,.6*e,.6*t,14),pop()}function createRectangleState(){const e=rectangleKeyframes[0];return{index:0,phase:"hold",frame:0,start:{...e},target:{...e},current:{...e}}}function updateRectangleAnimation(){if(rectangleState){if("transition"===rectangleState.phase){const e=easeInOutCubic(Math.min(1,rectangleState.frame/24));return rectangleState.current.width=lerp(rectangleState.start.width,rectangleState.target.width,e),rectangleState.current.height=lerp(rectangleState.start.height,rectangleState.target.height,e),rectangleState.current.rotation=lerp(rectangleState.start.rotation,rectangleState.target.rotation,e),rectangleState.frame++,void(rectangleState.frame>24&&(rectangleState.phase="hold",rectangleState.frame=0,rectangleState.current={...rectangleState.target}))}rectangleState.current={...rectangleState.target},rectangleState.frame++,rectangleState.frame>120&&(rectangleState.phase="transition",rectangleState.frame=0,rectangleState.start={...rectangleState.target},rectangleState.index=(rectangleState.index+1)%rectangleKeyframes.length,rectangleState.target={...rectangleKeyframes[rectangleState.index]})}}function easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}